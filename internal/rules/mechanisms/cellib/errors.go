// Copyright 2023 Dimitrij Drus <dadrus@gmx.de>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

package cellib

import (
	"errors"
	"fmt"
	"reflect"
	"slices"

	"github.com/google/cel-go/cel"
	"github.com/google/cel-go/common/types"
	"github.com/google/cel-go/common/types/ref"
	"github.com/google/cel-go/common/types/traits"
	"github.com/google/cel-go/ext"

	"github.com/dadrus/heimdall/internal/heimdall"
	"github.com/dadrus/heimdall/internal/x"
)

//nolint:gochecknoglobals
var (
	errType    = cel.ObjectType(reflect.TypeOf(Error{}).String(), traits.ComparerType)
	errTypeDef = cel.ObjectType(reflect.TypeOf(ErrorType{}).String(), traits.ComparerType)
)

type ErrorType struct {
	types []error

	current error
}

func (e ErrorType) ConvertToNative(_ reflect.Type) (any, error) {
	return nil, fmt.Errorf("%w: 'ErrorType' cannot be converted to any native type", errTypeConversion)
}

func (e ErrorType) ConvertToType(typeVal ref.Type) ref.Val {
	switch typeVal {
	case errTypeDef:
		return e
	case cel.TypeType:
		return errTypeDef
	}

	return types.NewErr("type conversion error from 'ErrorType' to '%s'", typeVal)
}

func (e ErrorType) Equal(other ref.Val) ref.Val {
	otherEt, ok := other.(ErrorType)
	if !ok {
		return types.False
	}

	if len(e.types) != 0 && len(otherEt.types) != 0 {
		return types.Bool(slices.Equal(e.types, otherEt.types))
	}

	cur := x.IfThenElse(e.current != nil, e.current, otherEt.current)
	errTypes := x.IfThenElse(len(e.types) != 0, e.types, otherEt.types)

	for _, v := range errTypes {
		if errors.Is(cur, v) {
			return types.True
		}
	}

	return types.False
}

func (e ErrorType) Type() ref.Type { return errType }

func (e ErrorType) Value() any { return e }

type Error struct {
	errType ErrorType

	Source string
}

func (e Error) ConvertToNative(typeDesc reflect.Type) (any, error) {
	if reflect.TypeOf(e.errType.current).AssignableTo(typeDesc) {
		return e.errType.current, nil
	}

	return nil, fmt.Errorf("%w: from 'Error' to '%v'", errTypeConversion, typeDesc)
}

func (e Error) ConvertToType(typeVal ref.Type) ref.Val {
	switch typeVal {
	case errType:
		return e
	case cel.TypeType:
		return e.errType
	}

	return types.NewErr("type conversion error from 'Error' to '%s'", typeVal)
}

func (e Error) Equal(other ref.Val) ref.Val {
	if otherErr, ok := other.(Error); ok {
		// the values MUST be equal here
		return types.Bool(e.errType.current == otherErr.errType.current) // nolint: errorlint,err113
	}

	return types.False
}

func (e Error) Type() ref.Type { return errType }

func (e Error) Value() any { return e }

func WrapError(err error) Error {
	var (
		handlerIdentifier interface{ ID() string }
		source            string
	)

	if ok := errors.As(err, &handlerIdentifier); ok {
		source = handlerIdentifier.ID()
	} else {
		source = ""
	}

	return Error{errType: ErrorType{current: err}, Source: source}
}

func Errors() cel.EnvOption {
	return cel.Lib(errorsLib{})
}

type errorsLib struct{}

func (errorsLib) LibraryName() string {
	return "dadrus.heimdall.errors"
}

func (errorsLib) ProgramOptions() []cel.ProgramOption {
	return []cel.ProgramOption{}
}

func (errorsLib) CompileOptions() []cel.EnvOption {
	return []cel.EnvOption{
		ext.NativeTypes(reflect.TypeOf(Error{})),
		cel.Variable("Error", errType),

		cel.Constant("authentication_error", cel.DynType,
			ErrorType{types: []error{heimdall.ErrAuthentication}}),
		cel.Constant("authorization_error", cel.DynType,
			ErrorType{types: []error{heimdall.ErrAuthorization}}),
		cel.Constant("communication_error", cel.DynType,
			ErrorType{types: []error{heimdall.ErrCommunication, heimdall.ErrCommunicationTimeout}}),
		cel.Constant("internal_error", cel.DynType,
			ErrorType{types: []error{heimdall.ErrInternal, heimdall.ErrConfiguration}}),
		cel.Constant("precondition_error", cel.DynType,
			ErrorType{types: []error{heimdall.ErrArgument}}),
	}
}
