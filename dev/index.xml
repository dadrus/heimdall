<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Heimdall - a cloud native Identity Aware Proxy and Access Control Decision service on Heimdall</title><link>https://dadrus.github.io/</link><description>Recent content in Heimdall - a cloud native Identity Aware Proxy and Access Control Decision service on Heimdall</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 05 Jun 2022 20:03:18 +0200</lastBuildDate><atom:link href="https://dadrus.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Discover heimdall</title><link>https://dadrus.github.io/docs/getting_started/discover_heimdall/</link><pubDate>Wed, 29 Nov 2023 22:03:28 +0200</pubDate><guid>https://dadrus.github.io/docs/getting_started/discover_heimdall/</guid><description>What is heimdall? Heimdall is a cloud native identity aware proxy and access control decision service inspired by the Zero Trust idea. It brings together authentication and authorization systems and can be thought as an orchestrator for these in front of your services, allowing however completely retaining control even without the need for any type of maintenance in your own code.
You can use it
integrated into available proxies and API gateways, allowing implementation of Edge-level Authorization Architectures, or</description></item><item><title>Install heimdall</title><link>https://dadrus.github.io/docs/getting_started/installation/</link><pubDate>Mon, 25 Jul 2022 18:22:50 +0200</pubDate><guid>https://dadrus.github.io/docs/getting_started/installation/</guid><description>Source Code You can always build a copy of heimdall by following the following instructions for your OS/environment.
Prerequisites git
The Go programming language &amp;gt;= 1.25
Download Retrieve the latest copy of heimdall source code by cloning the git repository
$ git clone git@github.com:dadrus/heimdall.git Build with go Build using a single line with go build
$ CGO_ENABLED=0 go build -trimpath -ldflags=&amp;#34;-buildid= -w -s -X github.com/dadrus/heimdall/version.Version==my-custom-build&amp;#34; The flags are set by intention.</description></item><item><title>Protect an Application</title><link>https://dadrus.github.io/docs/getting_started/protect_an_app/</link><pubDate>Mon, 04 Mar 2024 08:54:47 +0200</pubDate><guid>https://dadrus.github.io/docs/getting_started/protect_an_app/</guid><description>Overview In this guide we’re going to configure two setups, both protecting a service which exposes a couple of endpoints:
The /public endpoint is as the name implies public. Every request to it should be forwarded as is.
The /user endpoint should only be accessible to users with the role user.
The /admin endpoint should only be accessible to users with the role admin and
the /private endpoint, as well as any other potentially exposed endpoint should not be accessible at all.</description></item><item><title>Contour Integration</title><link>https://dadrus.github.io/guides/proxies/contour/</link><pubDate>Wed, 02 Aug 2023 17:10:52 +0200</pubDate><guid>https://dadrus.github.io/guides/proxies/contour/</guid><description>Contour is an open source, high performance ingress controller for Kubernetes, implementing a control plane for Envoy edge and a service proxy.
When operating heimdall in Decision Operation Mode exposing Envoy’s external authorization GRPC protocol, integration with Contour can be achieved by creating an ExtensionService resource for heimdall and either an HTTPProxy resource for the upstream service, referencing the aforesaid ExtensionService, or configure Contour to use it globally (for all routes).</description></item><item><title>Pipelines</title><link>https://dadrus.github.io/docs/concepts/pipelines/</link><pubDate>Tue, 29 Nov 2022 22:29:36 +0200</pubDate><guid>https://dadrus.github.io/docs/concepts/pipelines/</guid><description>Overview Pipelines are specified in rules and are used to authenticate and authorize the particular requests, as well as to handle encountered errors.
As described in the Discover heimdall chapter and also shown in the diagram below, central aspects of heimdall are upstream specific pipelines, which allow you orchestrating different services to authenticate, enrich and authorize incoming HTTP requests, transform the resulting subject information into a format, or obtain credentials required for the communication with the particular upstream services.</description></item><item><title>Emissary Ingress Integration</title><link>https://dadrus.github.io/guides/proxies/emissary/</link><pubDate>Mon, 21 Aug 2023 15:23:41 +0200</pubDate><guid>https://dadrus.github.io/guides/proxies/emissary/</guid><description>Emissary-Ingress is an Envoy-powered open source, high performance ingress controller and API Gateway for Kubernetes from Ambassador Labs.
When operating heimdall in Decision Operation Mode, integration with Emissary-Ingress can be achieved by creating an AuthService resource for heimdall. If you’re using the commercial Ambassador Edge Stack, you have to use the External Filter instead, which spec is more or less identical to the AuthService resource referenced above. In both cases the underlying Envoy proxy will be configured to delegate authentication and authorization of all incoming requests for all routes to heimdall.</description></item><item><title>Mechanisms</title><link>https://dadrus.github.io/docs/concepts/mechanisms/</link><pubDate>Tue, 29 Nov 2022 22:31:36 +0200</pubDate><guid>https://dadrus.github.io/docs/concepts/mechanisms/</guid><description>Mechanism Categories All supported mechanisms fall into the following five categories, each implementing different mechanisms types (addressing different protocols or scenarios):
Authenticators, which inspect HTTP requests for presence of authentication objects, like e.g. the presence of a specific cookie. If such objects exist, authenticators verify the related authentication status and obtain information about the corresponding subject. A subject, could be a user who tries to use particular functionality of the upstream service, a machine (if you have machine-2-machine interaction), or something different.</description></item><item><title>Envoy Integration</title><link>https://dadrus.github.io/guides/proxies/envoy/</link><pubDate>Sun, 18 Dec 2022 00:13:59 +0200</pubDate><guid>https://dadrus.github.io/guides/proxies/envoy/</guid><description>Envoy is a high performance distributed proxy designed for single services and applications, as well as a communication bus and “universal data plane” designed for large microservice “service mesh” architectures. When operating heimdall in Decision Operation Mode, integration with Envoy can be achieved by making use of an External Authorization filter. In such setup, Envoy delegates authentication and authorization to heimdall. If heimdall answers with a 200 OK HTTP code, Envoy grants access and forwards the original request to the upstream service.</description></item><item><title>Rules</title><link>https://dadrus.github.io/docs/concepts/rules/</link><pubDate>Tue, 29 Nov 2022 22:33:36 +0200</pubDate><guid>https://dadrus.github.io/docs/concepts/rules/</guid><description>You can compare the relation between mechanisms and rules to a relation between a catalogue at a car dealer and a real car, when you get it. So, mechanisms is what you can see and select in a catalogue (though, in case of heimdall you have to define that catalogue first) to compile your car and the rule is your car with real components and behaviour. In that sense when you define a rule, you specify which mechanisms should it be built from and whether you would like some &amp;#34;tuning&amp;#34; to be applied to better suit your needs.</description></item><item><title>HAProxy Integration</title><link>https://dadrus.github.io/guides/proxies/haproxy/</link><pubDate>Tue, 08 Aug 2023 07:32:14 +0200</pubDate><guid>https://dadrus.github.io/guides/proxies/haproxy/</guid><description>HAProxy (High Availability Proxy) is a popular open source, fast, and reliable solution providing load balancer and reverse proxy features for TCP- and HTTP-based applications, capable handling heavy load traffic and rerouting requests seamlessly across multiple workloads (e.g. web, application, database).
HAProxy is highly extensible thanks to Lua scripting support. For that reason the vanilla HAProxy does not implement any means of external authorization support and requires custom Lua code to achieve integration with heimdall.</description></item><item><title>Rule Provider</title><link>https://dadrus.github.io/docs/concepts/provider/</link><pubDate>Tue, 29 Nov 2022 22:31:36 +0200</pubDate><guid>https://dadrus.github.io/docs/concepts/provider/</guid><description>Rules Sets Regular, respectively upstream specific rules must somehow be organized, versioned and also loaded. So, there must be some structure allowing all of that. That structure is defined by the so-called rule sets.
A rule set can be considered to be just a file containing a list of rules and some additional meta information, like format version, name of the rule set and alike. Rule sets do also allow ordering of rules, e.</description></item><item><title>Operating Modes</title><link>https://dadrus.github.io/docs/concepts/operating_modes/</link><pubDate>Tue, 29 Nov 2022 22:29:36 +0200</pubDate><guid>https://dadrus.github.io/docs/concepts/operating_modes/</guid><description>Decision Mode In this mode you can integrate heimdall with existing reverse proxies, or API gateways (like Kong, NGNIX, Envoy, Traefik and much more)
Figure 1. Decision Deployment In this mode heimdall can be integrated with most probably all modern API gateways and reverse proxies as a so-called &amp;#34;authentication middleware&amp;#34;. Here the reverse proxy, respectively API gateway integrating with heimdall, will forward requests to heimdall by making use of its decision service endpoint for authentication and authorization purposes.</description></item><item><title>NGINX Integration</title><link>https://dadrus.github.io/guides/proxies/nginx/</link><pubDate>Fri, 29 Jul 2022 00:14:49 +0200</pubDate><guid>https://dadrus.github.io/guides/proxies/nginx/</guid><description>NGINX is an HTTP and reverse proxy server which became famous as one of the fastest web servers out there, heimdall can be integrated with by making use of the ngx_http_auth_request_module. In such setup, NGINX delegates authentication and authorization to heimdall. If heimdall answers with a 2XX code, NGINX grants access and forwards the original request to the upstream service. If heimdall returns 401 or 403, the access is denied with the corresponding error code.</description></item><item><title>Traefik Proxy Integration</title><link>https://dadrus.github.io/guides/proxies/traefik/</link><pubDate>Thu, 09 Jun 2022 18:59:49 +0200</pubDate><guid>https://dadrus.github.io/guides/proxies/traefik/</guid><description>Traefik Proxy is a modern HTTP proxy and load balancer for microservices, heimdall can be integrated with via the ForwardAuth Middleware while operated in the Decision Operation Mode. In such setup, traefik delegates authentication and authorization to heimdall. If heimdall answers with a 2XX code, traefik grants access and forwards the original request to the upstream service. Otherwise, the response from heimdall is returned to the client.
To achieve this, configure traefik</description></item><item><title>Integration with OPA</title><link>https://dadrus.github.io/guides/authz/opa/</link><pubDate>Fri, 04 Nov 2022 09:00:41 +0200</pubDate><guid>https://dadrus.github.io/guides/authz/opa/</guid><description>Open Policy Agent, or OPA, is an open source, general purpose policy engine, which decouples authorization, respectively policy decisions from other responsibilities of an application and can be used to implement fine-grained access control for your application. As such it is a very good fit for integrating with heimdall. And indeed, the integration is very simple. It is just a matter of using a Remote Authorizer or a Generic Contextualizer.</description></item><item><title>Configuration</title><link>https://dadrus.github.io/docs/operations/configuration/</link><pubDate>Fri, 08 Jul 2022 09:16:36 +0200</pubDate><guid>https://dadrus.github.io/docs/operations/configuration/</guid><description>Configuration in heimdall can refer to two different things:
the static startup configuration, which is the scope of this document and
the configuration of rules, respectively rule sets, which you can find here.
Elements in the static configuration set up the services, like decision service, which basically define the entry points, heimdall will listen to, the observability capabilities, like logging, the mechanism catalogue, the default rule, as well as the rule providers (these elements are not expected to change often).</description></item><item><title>CLI</title><link>https://dadrus.github.io/docs/operations/cli/</link><pubDate>Thu, 09 Jun 2022 18:57:50 +0200</pubDate><guid>https://dadrus.github.io/docs/operations/cli/</guid><description>Usage Patterns heimdall [command] [flags] [arguments] Use heimdall help to get overview about available commands, respectively heimdall [command] help for help on any command.
Flag’s usage:
# set flag_argument to flag(s) heimdall [--flag=flag_argument] [-f [flag_argument]] E.g.
heimdall validate config -c config.yaml Commands completion
Generates the autocompletion script for the specified shell.
health
Calls heimdall’s healthcheck endpoint to verify the status of the deployment.
help
Provides an overview about the available commands and their descriptions.</description></item><item><title>Observability</title><link>https://dadrus.github.io/docs/operations/observability/</link><pubDate>Wed, 03 Aug 2022 18:53:31 +0200</pubDate><guid>https://dadrus.github.io/docs/operations/observability/</guid><description>Logging Heimdall’s implementation uses zerolog - Zero Allocation JSON Logger, which can however also log in plain text. All emitted log statements include information related to distributed tracing (if tracing is enabled) so that not only log statements can be correlated to traces, but also all log statements belonging to single request/transaction can be correlated as well.
Configuration Logging configuration can be adjusted in the log property of heimdall’s configuration and supports following properties.</description></item><item><title>Caching</title><link>https://dadrus.github.io/docs/operations/cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dadrus.github.io/docs/operations/cache/</guid><description>Even some default caching is in place, and you can instruct heimdall to cache particular data for some amount of time, like e.g how long to cache the response from the JWKS endpoint when using the JWT Authenticator, all these options require a caching backend to be available. Otherwise, the corresponding configurations do not have any effect.
Configuration of that backend happens by making use of the cache property in heimdall’s configuration, which supports the following options:</description></item><item><title>Security</title><link>https://dadrus.github.io/docs/operations/security/</link><pubDate>Mon, 15 Aug 2022 08:33:35 +0200</pubDate><guid>https://dadrus.github.io/docs/operations/security/</guid><description>HTTP Header Security Considerations If trusted_proxies property is configured (see also the corresponding Decision and Proxy service configuration options) to let heimdall make use of different HTTP headers to build the URL for rule and HTTP method matching purposes, following logic apply:
The value for the used HTTP scheme is taken from the X-Forwarded-Proto header.
The value for the used HTTP host and port is taken from the X-Forwarded-Host header.</description></item><item><title>Decision Service</title><link>https://dadrus.github.io/docs/services/decision/</link><pubDate>Thu, 09 Jun 2022 18:55:36 +0200</pubDate><guid>https://dadrus.github.io/docs/services/decision/</guid><description>To make use of this service you have to start heimdall with heimdall serve decision or heimdall serve decision --envoy-grpc. By default, heimdall listens on 0.0.0.0:4456 endpoint for incoming requests in this mode of operation and also configures useful default timeouts, as well as buffer limits. No other options are configured. You can, and should however adjust the configuration for your needs.
Configuration The configuration of the Decision service can be adjusted in the decision property, which lives in the serve property of heimdall’s configuration and supports the following properties.</description></item><item><title>Proxy Service</title><link>https://dadrus.github.io/docs/services/proxy/</link><pubDate>Thu, 09 Jun 2022 18:55:45 +0200</pubDate><guid>https://dadrus.github.io/docs/services/proxy/</guid><description>To make use of this service you have to start Heimdall with heimdall serve proxy. By default, Heimdall listens on 0.0.0.0:4455 endpoint for incoming requests in this mode of operation and also configures useful default timeouts, amount of possible upstream connections is active and idle state, as well as buffer limits. No other options are configured. You can, and should however adjust the configuration for your needs.
Configuration The configuration of the Proxy endpoint can be adjusted in the proxy property, which lives in the serve property of heimdall’s configuration and supports the following properties.</description></item><item><title>Management Service</title><link>https://dadrus.github.io/docs/services/management/</link><pubDate>Thu, 09 Jun 2022 18:55:36 +0200</pubDate><guid>https://dadrus.github.io/docs/services/management/</guid><description>By default, Heimdall listens on 0.0.0.0:4457 endpoint for incoming requests and also configures useful default timeouts as well as buffer limits. No other options are configured. You can however adjust the configuration for your needs.
This service exposes the health and the JWKS endpoints.
Configuration The configuration for of the Management endpoint can be adjusted in the management property, which lives in the serve property of heimdall’s configuration and supports the following properties.</description></item><item><title>Catalogue</title><link>https://dadrus.github.io/docs/mechanisms/catalogue/</link><pubDate>Thu, 11 Jan 2024 15:01:21 +0200</pubDate><guid>https://dadrus.github.io/docs/mechanisms/catalogue/</guid><description>As described in Concepts section, mechanisms must be defined and configured before these can be used in rules. That is happening in the so-called mechanisms catalogue. On start up heimdall instantiates all defined and configured mechanisms and makes these available for usage in rules.
Catalogue Configuration The corresponding mechanisms catalogue resides under the mechanisms property of heimdall static configuration and is organized based on mechanism categories as also shown in the snippet below.</description></item><item><title>Objects, Templating &amp; Co</title><link>https://dadrus.github.io/docs/mechanisms/evaluation_objects/</link><pubDate>Wed, 10 Jan 2024 15:53:47 +0200</pubDate><guid>https://dadrus.github.io/docs/mechanisms/evaluation_objects/</guid><description>E.g. in one case, you want to have access to a particular request header. In another case you would like to add specific data to the resulting JWT created by heimdall. And in yet another case, you may want to check whether some expectations apply. These capabilities are described on this page.
Objects Objects represent state in the execution of a particular rule. These are the entities, either created or used by particular mechanisms and can represent things, like the actual request, the authenticated subject of the request and many more.</description></item><item><title>Authenticators</title><link>https://dadrus.github.io/docs/mechanisms/authenticators/</link><pubDate>Thu, 09 Jun 2022 18:56:56 +0200</pubDate><guid>https://dadrus.github.io/docs/mechanisms/authenticators/</guid><description>Some of the supported authenticator types may support or require additional configuration. The corresponding properties are annotated with mandatory, respectively optional to denote configuration requirement, as well as with overridable, not overriddable and partially overridable to indicate whether the property can be overridden in a rule pipeline.
Unauthorized This authenticator rejects all requests as unauthenticated (on HTTP response code level this is then mapped to 401 Unauthorized, hence the type name).</description></item><item><title>Authorizers</title><link>https://dadrus.github.io/docs/mechanisms/authorizers/</link><pubDate>Thu, 09 Jun 2022 18:57:03 +0200</pubDate><guid>https://dadrus.github.io/docs/mechanisms/authorizers/</guid><description>Some of the authorizers may support or require additional configuration. The corresponding properties are annotated with mandatory, respectively optional to denote configuration requirement, as well as with overridable, not overriddable and partially overridable to indicate whether the property can be overridden in a rule pipeline.
Allow As the name implies, this authorizer allows any request passing through. This authorizer type also doesn’t have any configuration options.
To enable the usage of this authorizer, you have to set the type property to allow.</description></item><item><title>Contextualizers</title><link>https://dadrus.github.io/docs/mechanisms/contextualizers/</link><pubDate>Thu, 09 Jun 2022 18:57:10 +0200</pubDate><guid>https://dadrus.github.io/docs/mechanisms/contextualizers/</guid><description>Some of the contextualizers may support or require additional configuration. The corresponding properties are annotated with mandatory, respectively optional to denote configuration requirement, as well as with overridable, not overriddable and partially overridable to indicate whether the property can be overridden in a rule pipeline.
Generic This mechanism allows you to communicate to any API you want to fetch further information about the subject. Typical scenario is getting specific attributes for later authorization purposes which are not known to the authentication system and thus were not made available in Subject’s Attributes property.</description></item><item><title>Finalizers</title><link>https://dadrus.github.io/docs/mechanisms/finalizers/</link><pubDate>Thu, 09 Jun 2022 18:57:16 +0200</pubDate><guid>https://dadrus.github.io/docs/mechanisms/finalizers/</guid><description>Some finalizers may support or require additional configuration. The corresponding properties are annotated with mandatory, respectively optional to denote configuration requirement, as well as with overridable, not overriddable and partially overridable to indicate whether the property can be overridden in a rule pipeline.
Noop As the name implies, this finalizer does nothing. This finalizer type also doesn’t have any configuration options.
To enable the usage of this finalizer, you have to set the type property to noop.</description></item><item><title>Error Handlers</title><link>https://dadrus.github.io/docs/mechanisms/error_handlers/</link><pubDate>Thu, 09 Jun 2022 18:57:29 +0200</pubDate><guid>https://dadrus.github.io/docs/mechanisms/error_handlers/</guid><description>Some of the error handlers may support or require additional configuration. The corresponding properties are annotated with mandatory, respectively optional to denote configuration requirement, as well as with overridable, not overriddable and partially overridable to indicate whether the property can be overridden in a rule pipeline.
Default This mechanism is always there and is executed if no other error handler mechanism is responsible for the error. Actually, there is no need to explicitly configure it.</description></item><item><title>Regular Rule</title><link>https://dadrus.github.io/docs/rules/regular_rule/</link><pubDate>Thu, 09 Jun 2022 22:13:32 +0200</pubDate><guid>https://dadrus.github.io/docs/rules/regular_rule/</guid><description>In simplest case a regular rule will just reuse mechanisms from a previously defined catalogue in its pipelines. In more complex cases a rule can reconfigure parts of used mechanisms. Which parts can be reconfigured, respectively overridden are mechanism specific and described in the mechanism specific documentation. Reconfiguration is always limited to the particular rule pipeline and does not affect other rules.
Configuration A single regular rule consists of the following properties:</description></item><item><title>Default Rule</title><link>https://dadrus.github.io/docs/rules/default_rule/</link><pubDate>Thu, 09 Jun 2022 22:13:32 +0200</pubDate><guid>https://dadrus.github.io/docs/rules/default_rule/</guid><description>Configuration The configuration of the default rule can be done by making use of the default_rule property and configuring the options shown below.
The default rule does not support all the properties, which can be configured in an regular rule. E.g. it can not be used to forward requests to an upstream service, heimdall is protecting. So, if you operate heimdall in the reverse proxy mode, the default rule should be configured to reject requests.</description></item><item><title>Rule Sets</title><link>https://dadrus.github.io/docs/rules/rule_sets/</link><pubDate>Thu, 09 Jun 2022 22:13:32 +0200</pubDate><guid>https://dadrus.github.io/docs/rules/rule_sets/</guid><description>Depending on the configured provider, the rules can be then loaded from e.g. a plain old configuration file, residing in the local file system, or even from a Kubernetes environment as a custom resource. Thus, the structure and format of a rule set depends on the provider used to load it. As of today, there are two supported formats:
as a regular JSON/YAML file, the so-called regular rule set, and</description></item><item><title>Rule Providers</title><link>https://dadrus.github.io/docs/rules/providers/</link><pubDate>Thu, 09 Jun 2022 22:13:54 +0200</pubDate><guid>https://dadrus.github.io/docs/rules/providers/</guid><description>Providers allow definition of sources to load the rule sets from. These make heimdall’s behavior dynamic. All providers, you want to enable for a heimdall instance must be configured within the providers section of heimdall’s configuration.
Below, you can find the description and configuration options for currently supported providers.
Filesystem The filesystem provider allows loading of regular rule sets in JSON or YAML format from a file system.
Configuration The configuration of this provider goes into the file_system property.</description></item><item><title>Type Definitions</title><link>https://dadrus.github.io/docs/configuration/types/</link><pubDate>Thu, 09 Jun 2022 18:56:56 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/types/</guid><description>Assertions This type enables configuration of required token and claim assertions. Depending on the object type (JWT or introspection response), the assertions apply to different parts of such objects.
scopes: Scopes Matcher (optional)
Required scopes given to the client.
audience: string array (optional)
Values to be matched in the aud claim. This assertion evaluates to true if at least one entry in the given audience array is present in the aud claim.</description></item><item><title>Reference</title><link>https://dadrus.github.io/docs/configuration/reference/</link><pubDate>Thu, 09 Jun 2022 18:57:50 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/reference/</guid><description>Below you can find possible contents (not exhaustive) for Heimdall’s config.yaml file. Head over to configuration documentation to get detailed explanation.
serve: decision: host: 127.0.0.1 port: 4468 respond: verbose: true with: accepted: code: 201 authorization_error: code: 404 authentication_error: code: 404 timeout: read: 2s write: 5s idle: 2m buffer_limit: read: 10KB write: 10KB tls: key_store: path: /path/to/key/store.pem password: VerySecure! trusted_proxies: - 192.168.1.0/24 proxy: host: 127.0.0.1 port: 4469 respond: verbose: true with: authorization_error: code: 404 authentication_error: code: 404 timeout: read: 2s write: 5s idle: 2m connections_limit: max_per_host: 10 max_idle: 100 max_idle_per_host: 50 buffer_limit: read: 10KB write: 10KB cors: allowed_origins: - example.</description></item></channel></rss>