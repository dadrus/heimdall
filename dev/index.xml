<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Heimdall - a cloud native Identity Aware Proxy and Access Control Decision service on Heimdall</title><link>https://dadrus.github.io/</link><description>Recent content in Heimdall - a cloud native Identity Aware Proxy and Access Control Decision service on Heimdall</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 05 Jun 2022 20:03:18 +0200</lastBuildDate><atom:link href="https://dadrus.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Welcome</title><link>https://dadrus.github.io/docs/welcome/</link><pubDate>Fri, 10 Jun 2022 17:30:17 +0200</pubDate><guid>https://dadrus.github.io/docs/welcome/</guid><description>Background The diagram below sketches how authentication and authorization is handled in most of today’s applications.
Figure 1. Typical deployment scenario On the one hand it allows the backend service to fully control the corresponding security requirements. On the other hand it has some limitations:
It works as long as there is just one authentication system.
When there are multiple backend services, which is typically the case in modern architectures, it requires each backend service to repetitively implement security related capabilities in its code, and related to this</description></item><item><title>Concepts</title><link>https://dadrus.github.io/docs/getting_started/concepts/</link><pubDate>Sat, 25 Jun 2022 14:29:17 +0200</pubDate><guid>https://dadrus.github.io/docs/getting_started/concepts/</guid><description>Everything you need to know.
Pipeline As described in the Welcome section and also shown in the diagram below, heimdall authenticates and authorizes incoming HTTP requests, rejecting unauthenticated or unauthorized ones, as well as enriches the valid requests with further contextual information and transforms resulting subject information into a format, required by the upstream services. This is done in upstream service specific rules, which assemble the required individual pipelines by making use of different mechanisms.</description></item><item><title>Decision Service Quickstart</title><link>https://dadrus.github.io/docs/getting_started/decision_service_quickstart/</link><pubDate>Wed, 08 Jun 2022 20:43:27 +0200</pubDate><guid>https://dadrus.github.io/docs/getting_started/decision_service_quickstart/</guid><description>This document describes a very simple use case in which you’ll see heimdall’s Decision service in action.
Prerequisites Download Heimdall in your flavor.
Docker, Podman, or other container runtime of your choice (examples are however using docker) (optionally) and
docker-compose (optionally)
Configure heimdall can be configured via environment variables, as well as using a configuration file. For simplicity reasons, we’ll use a configuration file here. So create a config file named config.</description></item><item><title>Proxy Service Quickstart</title><link>https://dadrus.github.io/docs/getting_started/proxy_service_quickstart/</link><pubDate>Tue, 26 Jul 2022 09:40:27 +0200</pubDate><guid>https://dadrus.github.io/docs/getting_started/proxy_service_quickstart/</guid><description>This document describes a simple use case in which you’ll see heimdall’s Proxy service in action. Here, we’ll create a minimal but complete environment for running heimdall with containers.
Prerequisites Docker and
docker-compose
Configure Heimdall can be configured via environment variables, as well as using a configuration file. For simplicity reasons, we’ll use a configuration file here.
Create a config file (config.yaml) with the following content:
log: level: info (1) mechanisms: authenticators: - id: anonymous_authenticator (2) type: anonymous authorizers: - id: deny_all_requests (3) type: deny - id: allow_all_requests (4) type: allow finalizers: - id: create_jwt (5) type: jwt default_rule: (6) methods: - GET - POST execute: - authenticator: anonymous_authenticator - authorizer: deny_all_requests providers: file_system: (7) src: /heimdall/conf/rule.</description></item><item><title>Configuration Introduction</title><link>https://dadrus.github.io/docs/getting_started/configuration_introduction/</link><pubDate>Fri, 08 Jul 2022 09:16:36 +0200</pubDate><guid>https://dadrus.github.io/docs/getting_started/configuration_introduction/</guid><description>Configuration in heimdall can refer to two different things:
the static startup configuration and
the configuration of rules, respectively rule sets
Elements in the static configuration set up the services, like decision service, which basically define the entry points, heimdall will listen to, the observability capabilities, like logging, the supported pipeline mechanisms, the default rule, as well as the rule providers (these elements are not expected to change often).</description></item><item><title>Install</title><link>https://dadrus.github.io/docs/operations/install/</link><pubDate>Mon, 25 Jul 2022 18:22:50 +0200</pubDate><guid>https://dadrus.github.io/docs/operations/install/</guid><description>Heimdall is shipped in multiple formats and architectures to suit a variety of deployment patterns. Available installation options are:
Source code
Binary
Container Image
Helm Chart
Source Code You can always build a copy of heimdall by following the following instructions for your OS/environment.
Prerequisites git
The Go programming language &amp;gt;= 1.21
Download Retrieve the latest copy of heimdall source code by cloning the git repository
$ git clone git@github.</description></item><item><title>CLI</title><link>https://dadrus.github.io/docs/operations/cli/</link><pubDate>Thu, 09 Jun 2022 18:57:50 +0200</pubDate><guid>https://dadrus.github.io/docs/operations/cli/</guid><description>Heimdall’s Command Line Interface
General heimdall [command] [flags] [arguments] Use heimdall help to get overview about available commands, respectively heimdall [command] help for help on any command.
Flag’s usage:
# set flag_argument to flag(s) heimdall [--flag=flag_argument] [-f [flag_argument]] E.g.
heimdall validate config -c config.yaml Commands completion
Generates the autocompletion script for the specified shell.
health
Calls heimdall’s healthcheck endpoint to verify the status of the deployment.
help
Provides an overview about the available commands and their descriptions.</description></item><item><title>Observability</title><link>https://dadrus.github.io/docs/operations/observability/</link><pubDate>Wed, 03 Aug 2022 18:53:31 +0200</pubDate><guid>https://dadrus.github.io/docs/operations/observability/</guid><description>Hemdall implements different observability mechanisms to support easier operation and integration in different APM products. The following sections provide insights about what can be expected.
Logging in Heimdall Heimdall’s implementation uses zerolog - Zero Allocation JSON Logger, which can however also log in plain text. All emitted log statements include information related to distributed tracing (if tracing is enabled) so that not only log statements can be correlated to traces, but also all log statements belonging to single request/transaction can be correlated as well.</description></item><item><title>Security</title><link>https://dadrus.github.io/docs/operations/security/</link><pubDate>Mon, 15 Aug 2022 08:33:35 +0200</pubDate><guid>https://dadrus.github.io/docs/operations/security/</guid><description>To operate heimdall in a secure way, you should configure heimdall accordingly. Following sections address the corresponding areas.
HTTP Header Security Considerations If trusted_proxies property is configured (see also the corresponding Decision and Proxy service configuration options) to let heimdall make use of different HTTP headers to build the URL for rule and HTTP method matching purposes, following logic apply:
The value for the used HTTP schema is taken from the X-Forwarded-Proto header.</description></item><item><title>Contour Integration</title><link>https://dadrus.github.io/docs/guides/contour/</link><pubDate>Wed, 02 Aug 2023 17:10:52 +0200</pubDate><guid>https://dadrus.github.io/docs/guides/contour/</guid><description>Contour is an open source, high performance ingress controller for Kubernetes, implementing a control plane for Envoy edge and a service proxy.
When operating heimdall in Decision Operation Mode exposing Envoy’s external authorization GRPC protocol, integration with Contour can be achieved by creating an ExtensionService resource for heimdall and either an HTTPProxy resource for the upstream service, referencing the aforesaid ExtensionService, or configure Contour to use it globally (for all routes).</description></item><item><title>Emissary Ingress Integration</title><link>https://dadrus.github.io/docs/guides/emissary/</link><pubDate>Mon, 21 Aug 2023 15:23:41 +0200</pubDate><guid>https://dadrus.github.io/docs/guides/emissary/</guid><description>Emissary-Ingress is an Envoy-powered open source, high performance ingress controller and API Gateway for Kubernetes from Ambassador Labs.
When operating heimdall in Decision Operation Mode, integration with Emissary-Ingress can be achieved by creating an AuthService resource for heimdall. If you’re using the commercial Ambassador Edge Stack, you have to use the External Filter instead, which spec is more or less identical to the AuthService resource referenced above. In both cases the underlying Envoy proxy will be configured to delegate authentication and authorization of all incoming requests for all routes to heimdall.</description></item><item><title>Envoy Integration</title><link>https://dadrus.github.io/docs/guides/envoy/</link><pubDate>Sun, 18 Dec 2022 00:13:59 +0200</pubDate><guid>https://dadrus.github.io/docs/guides/envoy/</guid><description>Envoy is a high performance distributed proxy designed for single services and applications, as well as a communication bus and “universal data plane” designed for large microservice “service mesh” architectures. When operating heimdall in Decision Operation Mode, integration with Envoy can be achieved by making use of an External Authorization filter. In such setup, Envoy delegates authentication and authorization to heimdall. If heimdall answers with a 200 OK HTTP code, Envoy grants access and forwards the original request to the upstream service.</description></item><item><title>HAProxy Integration</title><link>https://dadrus.github.io/docs/guides/haproxy/</link><pubDate>Tue, 08 Aug 2023 07:32:14 +0200</pubDate><guid>https://dadrus.github.io/docs/guides/haproxy/</guid><description>HAProxy (High Availability Proxy) is a popular open source, fast, and reliable solution providing load balancer and reverse proxy features for TCP- and HTTP-based applications, capable handling heavy load traffic and rerouting requests seamlessly across multiple workloads (e.g. web, application, database).
HAProxy is highly extensible thanks to Lua scripting support. For that reason the vanilla HAProxy does not implement any means of external authorization support and requires custom Lua code to achieve integration with heimdall.</description></item><item><title>Integration with OPA</title><link>https://dadrus.github.io/docs/guides/opa/</link><pubDate>Fri, 04 Nov 2022 09:00:41 +0200</pubDate><guid>https://dadrus.github.io/docs/guides/opa/</guid><description>Open Policy Agent, or OPA, is an open source, general purpose policy engine, which decouples authorization, respectively policy decisions from other responsibilities of an application and can be used to implement fine-grained access control for your application. As such it is a very good fit for integrating with heimdall. And indeed, the integration is very simple. It is just a matter of using a Remote Authorizer or a Generic Contextualizer.</description></item><item><title>NGINX Integration</title><link>https://dadrus.github.io/docs/guides/nginx/</link><pubDate>Fri, 29 Jul 2022 00:14:49 +0200</pubDate><guid>https://dadrus.github.io/docs/guides/nginx/</guid><description>NGINX is an HTTP and reverse proxy server which became famous as one of the fastest web servers out there, heimdall can be integrated with by making use of the ngx_http_auth_request_module. In such setup, NGINX delegates authentication and authorization to heimdall. If heimdall answers with a 2XX code, NGINX grants access and forwards the original request to the upstream service. If heimdall returns 401 or 403, the access is denied with the corresponding error code.</description></item><item><title>Traefik Proxy Integration</title><link>https://dadrus.github.io/docs/guides/traefik/</link><pubDate>Thu, 09 Jun 2022 18:59:49 +0200</pubDate><guid>https://dadrus.github.io/docs/guides/traefik/</guid><description>Traefik Proxy is a modern HTTP proxy and load balancer for microservices, heimdall can be integrated with via the ForwardAuth Middleware while operated in the Decision Operation Mode. In such setup, traefik delegates authentication and authorization to heimdall. If heimdall answers with a 2XX code, traefik grants access and forwards the original request to the upstream service. Otherwise, the response from heimdall is returned to the client.
To achieve this, configure traefik</description></item><item><title>Decision</title><link>https://dadrus.github.io/docs/configuration/services/decision/</link><pubDate>Thu, 09 Jun 2022 18:55:36 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/services/decision/</guid><description>Decision is one of the operating modes supported by heimdall, used if you start heimdall with heimdall serve decision or heimdall serve decision --envoy-grpc. By default, heimdall listens on 0.0.0.0:4456 endpoint for incoming requests in this mode of operation and also configures useful default timeouts, as well as buffer limits. No other options are configured. You can, and should however adjust the configuration for your needs.
This service exposes only the Decision service endpoint.</description></item><item><title>Proxy</title><link>https://dadrus.github.io/docs/configuration/services/proxy/</link><pubDate>Thu, 09 Jun 2022 18:55:45 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/services/proxy/</guid><description>Proxy is one of the operating modes supported by Heimdall, used if you start Heimdall with heimdall serve proxy. By default, Heimdall listens on 0.0.0.0:4455 endpoint for incoming requests in this mode of operation and also configures useful default timeouts, amount of possible upstream connections is active and idle state, as well as buffer limits. No other options are configured. You can, and should however adjust the configuration for your needs.</description></item><item><title>Management</title><link>https://dadrus.github.io/docs/configuration/services/management/</link><pubDate>Thu, 09 Jun 2022 18:55:36 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/services/management/</guid><description>The Management service is always there, regardless of the mode of operation Heimdall is started in. By default, Heimdall listens on 0.0.0.0:4457 endpoint for incoming requests and also configures useful default timeouts as well as buffer limits. No other options are configured. You can however adjust the configuration for your needs.
This service exposes the health and the JWKS endpoints.
Configuration The configuration for of the Management endpoint can be adjusted in the management property, which lives in the serve property of heimdall’s configuration and supports the following properties.</description></item><item><title>Logging</title><link>https://dadrus.github.io/docs/configuration/observability/logging/</link><pubDate>Thu, 09 Jun 2022 18:56:07 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/observability/logging/</guid><description>Heimdall logs concern everything that happens to Heimdall itself (startup, configuration, events, shutdown, and so on). Logs are written to stdout by default in text format.
Configuration Logging configuration can be adjusted in the log property of heimdall’s configuration and supports following properties.
format: string (optional)
With text and gelf being the available formats. text is the default format. And gelf defines a JSON format adhering to GELF.
Usage of text (default) format is not recommended for production deployments as it requires more computational resources and is hence slow.</description></item><item><title>Metrics</title><link>https://dadrus.github.io/docs/configuration/observability/metrics/</link><pubDate>Thu, 09 Jun 2022 22:16:45 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/observability/metrics/</guid><description>Heimdall generates OpenTelemetry metrics and can export these either by pushing these to an OTEL collector (the default behavior), or by exposing them via a pull based service (Prometheus style).
Metrics are generated and exported by default. If this is not desired, you can explicitly disable this behavior by making use of the configuration options, described below. Alternatively, you can set the OTEL_METRICS_EXPORTER environment variable to none.
Configuration Configuration for this service can be adjusted in the metrics property of heimdall’s configuration by making use of the following properties.</description></item><item><title>Tracing</title><link>https://dadrus.github.io/docs/configuration/observability/tracing/</link><pubDate>Thu, 09 Jun 2022 18:56:12 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/observability/tracing/</guid><description>Heimdall makes use of OpenTelemetry for distributed tracing to support recording of paths taken by requests as they propagate through multi-service architectures and supports all environment variables including the defined values according to OpenTelemetry Environment Variable Specification.
Configuration By default, tracing is enabled and can be disabled and slightly tuned in the tracing property of heimdall’s configuration, which has the following properties.
enabled: boolean (optional)
By making use of this property, you can configure heimdall to enable or disable tracing.</description></item><item><title>Runtime Profiling</title><link>https://dadrus.github.io/docs/configuration/observability/profiling/</link><pubDate>Wed, 18 Jan 2023 19:21:48 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/observability/profiling/</guid><description>Heimdall can expose runtime profiling data in the profile.proto format (also known as pprof format), which can be consumed by many APM tools, like Google’s pprof, Grafana Phlare, Pyroscope and many more for analysis and visualization purposes. By default, this service is disabled. If enabled, the profiling information is available on 127.0.0.1:10251/debug/pprof endpoint.
Configuration Configuration for this service can be adjusted in the profiling property of heimdall’s configuration by making use of the following properties.</description></item><item><title>Rules Overview</title><link>https://dadrus.github.io/docs/configuration/rules/overview/</link><pubDate>Thu, 09 Jun 2022 22:13:32 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/rules/overview/</guid><description>This section explains how rules can be defined and used in detail. Before diving onto this topic, we recommend to make yourself familiar with the principal architecture and concepts.
Core aspects of heimdall are rules. These let heimdall execute logic required by your upstream service to authenticate, authorize the incoming requests, enrich the information about the subject and transform it according your needs. However, to be able to define even a single rule, you must configure pipeline mechanisms, which you can then use in any rules, you define.</description></item><item><title>Mechanisms Overview</title><link>https://dadrus.github.io/docs/configuration/rules/pipeline_mechanisms/overview/</link><pubDate>Thu, 09 Jun 2022 18:56:56 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/rules/pipeline_mechanisms/overview/</guid><description>All mechanisms supported by heimdall fall into following categories:
Authenticators, which inspect HTTP requests for presence of authentication objects, like e.g. the presence of a specific cookie. If such objects exist, authenticators verify the related authentication status and obtain information about the corresponding subject. A subject, could be a user who tries to use particular functionality of the upstream service, a machine (if you have machine-2-machine interaction), or something different.</description></item><item><title>Authenticators</title><link>https://dadrus.github.io/docs/configuration/rules/pipeline_mechanisms/authenticators/</link><pubDate>Thu, 09 Jun 2022 18:56:56 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/rules/pipeline_mechanisms/authenticators/</guid><description>Authenticators inspect HTTP requests for presence of authentication objects, like e.g. the presence of a specific cookie. If such objects exist, authenticators verify the related authentication status and obtain information about the corresponding subject. A subject, could be a user, trying to use particular functionality of the upstream service, a machine (if you have machine-2-machine interaction), or something different. Authenticators ensure the subject is authenticated and the information available about it is valid.</description></item><item><title>Authorizers</title><link>https://dadrus.github.io/docs/configuration/rules/pipeline_mechanisms/authorizers/</link><pubDate>Thu, 09 Jun 2022 18:57:03 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/rules/pipeline_mechanisms/authorizers/</guid><description>Authorizers ensure that the Subject obtained via an authenticator has the required permissions to submit the given HTTP request and thus to execute the corresponding logic in the upstream service. E.g. a specific endpoint of the upstream service might only be accessible to a &amp;#34;user&amp;#34; from the &amp;#34;admin&amp;#34; group, or to an HTTP request if a specific HTTP header is set.
Authorizer Types The following sections describe the available authorizer types in more detail.</description></item><item><title>Contextualizers</title><link>https://dadrus.github.io/docs/configuration/rules/pipeline_mechanisms/contextualizers/</link><pubDate>Thu, 09 Jun 2022 18:57:10 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/rules/pipeline_mechanisms/contextualizers/</guid><description>Contextualizers enrich the information about the Subject obtained via an authenticator mechanism with further information, required by either the endpoint of the upstream service itself or an authorizer mechanism. This can be handy if the actual authentication system doesn’t have all information about the subject (which is usually the case in microservice architectures), or if dynamic information about the subject, like the current location based on the IP address, is required.</description></item><item><title>Finalizers</title><link>https://dadrus.github.io/docs/configuration/rules/pipeline_mechanisms/finalizers/</link><pubDate>Thu, 09 Jun 2022 18:57:16 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/rules/pipeline_mechanisms/finalizers/</guid><description>Finalizers, as the name implies, finalize the execution of the pipeline and enrich the request with data such as subject information or authentication tokens required by the upstream service. The available options range from adding a simple header over a structured JWT in a specific header, to driving specific protocols, e.g. to obtain a token required by the upstream service.
Finalizer Types The following sections describe the available finalizer types in more detail.</description></item><item><title>Error Handlers</title><link>https://dadrus.github.io/docs/configuration/rules/pipeline_mechanisms/error_handlers/</link><pubDate>Thu, 09 Jun 2022 18:57:29 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/rules/pipeline_mechanisms/error_handlers/</guid><description>Error Handlers are responsible for execution of logic if any of the authenticators, authorizers, contextualizers or finalizers fails. The error handler mechanisms range from a simple error response to the client which sent the request to sophisticated ones, supporting complex logic and redirects.
Error Handler Types The following sections describe the available error handler types in more detail. Some of these may support or require additional configuration. The corresponding properties are annotated with mandatory, respectively optional to denote configuration requirement, as well as with overridable, not overriddable and partially overridable to indicate whether the property can be overridden in a rule pipeline.</description></item><item><title>Rule</title><link>https://dadrus.github.io/docs/configuration/rules/configuration/</link><pubDate>Thu, 09 Jun 2022 22:13:32 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/rules/configuration/</guid><description>Rules are the heart of heimdall. These allow execution of arbitrary logic, required by your upstream service. This section describes everything related to the configuration of a particular rule and how can these be combined to rule sets, which can then be loaded by a rule provider.
Rule Configuration A single rule consists of the following properties:
id: string (mandatory)
The unique identifier of a rule. It must be unique across all rules loaded by the same Rule Provider.</description></item><item><title>Default Rule</title><link>https://dadrus.github.io/docs/configuration/rules/default/</link><pubDate>Thu, 09 Jun 2022 22:13:32 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/rules/default/</guid><description>Heimdall lets you not only define upstream service specific rules, it does also support a definition of an optional default rule, which, if defined, kicks in, if no other rule matches. This way you can ensure secure defaults by simultaneously reducing the amount of work while defining upstream service API specific rules. That is, an upstream service API specific rule can reuse definitions from the default rule.
The default rule does not support all the properties, which can be configured in a specific rule.</description></item><item><title>Rule Providers</title><link>https://dadrus.github.io/docs/configuration/rules/providers/</link><pubDate>Thu, 09 Jun 2022 22:13:54 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/rules/providers/</guid><description>Providers define the sources to load the Rule Sets from. These make heimdall’s behavior dynamic. All providers, you want to enable for a heimdall instance must be configured within the providers section of heimdall’s configuration.
Supported providers, including the corresponding configuration options are described below
Filesystem The filesystem provider allows loading of rule sets in a format defined in Rule Sets from a file system. The configuration of this provider goes into the file_system property.</description></item><item><title>Cryptographic Material</title><link>https://dadrus.github.io/docs/configuration/cryptographic_material/</link><pubDate>Mon, 15 Aug 2022 06:47:22 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/cryptographic_material/</guid><description>Some Finalizers, which, as the name implies, finalize the successful execution of the pipeline, can generated signed objects, like a JWT, to be forwarded to the upstream services. In such cases Heimdall acts as an issuer of such objects and needs at least corresponding key material.
Configuration The configuration related to the issuance of signed objects can be done using the signer property, which resides on the top level of heimdall’s configuration and supports the following properties.</description></item><item><title>Configuration Types</title><link>https://dadrus.github.io/docs/configuration/reference/types/</link><pubDate>Thu, 09 Jun 2022 18:56:56 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/reference/types/</guid><description>Assertions This type enables configuration of required token and claim assertions. Depending on the object type (JWT or introspection response), the assertions apply to different parts of such objects.
scopes: Scopes Matcher (optional)
Required scopes given to the client.
audience: string array (optional)
Required entries in the aud claim. Both cases, either as whitespace separated string, or a JSON array are considered.
issuers: string array (mandatory)
Issuers to trust. At least one issuer must be configured.</description></item><item><title>Static Configuration Reference</title><link>https://dadrus.github.io/docs/configuration/reference/reference/</link><pubDate>Thu, 09 Jun 2022 18:57:50 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/reference/reference/</guid><description>Below you can find possible contents (not exhaustive) for Heimdall’s config.yaml file. Head over to configuration documentation to get detailed explanation.
serve: decision: host: 127.0.0.1 port: 4468 respond: verbose: true with: accepted: code: 201 authorization_error: code: 404 authentication_error: code: 404 timeout: read: 2s write: 5s idle: 2m buffer_limit: read: 10KB write: 10KB tls: key_store: path: /path/to/key/store.pem password: VerySecure! trusted_proxies: - 192.168.1.0/24 proxy: host: 127.0.0.1 port: 4469 respond: verbose: true with: authorization_error: code: 404 authentication_error: code: 404 timeout: read: 2s write: 5s idle: 2m connections_limit: max_per_host: 10 max_idle: 100 max_idle_per_host: 50 buffer_limit: read: 10KB write: 10KB cors: allowed_origins: - example.</description></item></channel></rss>